#!/usr/bin/env python3
"""
Web桥接服务器 - 连接Web界面和C服务器
"""

from flask import Flask, request, jsonify, send_from_directory, Response
from flask_cors import CORS
import socket
import struct
import os
import hashlib
import zipfile
import io
import tempfile

app = Flask(__name__)
CORS(app)  # 允许跨域请求

# C服务器配置
C_SERVER_HOST = '127.0.0.1'
C_SERVER_PORT = 9000

def connect_to_c_server():
    """连接到C服务器"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((C_SERVER_HOST, C_SERVER_PORT))
        return sock
    except Exception as e:
        print(f"连接C服务器失败: {e}")
        return None

def send_string(sock, data):
    """发送字符串到C服务器"""
    data_bytes = data.encode('utf-8')
    length = len(data_bytes)
    print(f"[DEBUG] 发送字符串: '{data}' (长度: {length})")
    sock.send(struct.pack('!I', length))  # 发送长度（网络字节序）
    sock.send(data_bytes)  # 发送数据

def recv_response(sock):
    """接收C服务器响应"""
    try:
        response = sock.recv(1)
        return response[0] if response else 0
    except:
        return 0

@app.route('/')
def index():
    """主页 - 返回登录页面"""
    return send_from_directory('.', 'login.html')

@app.route('/login.html')
def login_page():
    """登录页面"""
    return send_from_directory('.', 'login.html')

@app.route('/dashboard.html')
def dashboard_page():
    """主功能界面"""
    return send_from_directory('.', 'dashboard.html')

@app.route('/web_client.html')
def old_client():
    """旧版客户端（兼容性）"""
    return send_from_directory('.', 'web_client.html')

@app.route('/api/login', methods=['POST'])
def login():
    """用户登录API"""
    data = request.json
    username = data.get('username', '')
    password = data.get('password', '')
    
    if not username or not password:
        return jsonify({'success': False, 'message': '用户名和密码不能为空'})
    
    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})
    
    try:
        # 发送登录命令
        sock.send(b'L')
        
        # 发送用户名
        send_string(sock, username)
        
        # 发送密码
        send_string(sock, password)
        
        # 接收响应
        result = recv_response(sock)
        
        if result == 1:
            return jsonify({'success': True, 'message': '登录成功'})
        else:
            return jsonify({'success': False, 'message': '用户名或密码错误'})
            
    except Exception as e:
        return jsonify({'success': False, 'message': f'登录失败: {str(e)}'})
    finally:
        sock.close()

@app.route('/api/register', methods=['POST'])
def register():
    """用户注册API"""
    data = request.json
    username = data.get('username', '')
    password = data.get('password', '')
    
    if not username or not password:
        return jsonify({'success': False, 'message': '用户名和密码不能为空'})
    
    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})
    
    try:
        # 发送注册命令
        sock.send(b'R')
        
        # 发送用户名
        send_string(sock, username)
        
        # 发送密码
        send_string(sock, password)
        
        # 接收响应
        result = recv_response(sock)
        
        if result == 1:
            return jsonify({'success': True, 'message': '注册成功'})
        else:
            return jsonify({'success': False, 'message': '注册失败，用户名可能已存在'})
            
    except Exception as e:
        return jsonify({'success': False, 'message': f'注册失败: {str(e)}'})
    finally:
        sock.close()

@app.route('/api/files', methods=['GET'])
def list_files():
    """获取文件列表API"""
    username = request.args.get('username', '')
    path = request.args.get('path', '/')

    if not username:
        return jsonify({'success': False, 'message': '用户名不能为空'})
    
    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})
    
    try:
        print(f"[DEBUG] 获取文件列表: 用户={username}, 路径={path}")

        # 发送目录列表命令
        sock.send(b'S')

        # 发送用户名
        send_string(sock, username)

        # 发送目标路径 (空字符串表示根目录)
        target_path = "" if path == "/" else path
        send_string(sock, target_path)

        # 接收响应
        result = recv_response(sock)
        print(f"[DEBUG] 服务器响应: {result}")
        
        if result == 1:
            # 接收条目数量
            count_data = sock.recv(4)
            print(f"[DEBUG] 接收到条目数量数据: {len(count_data)} 字节")
            if len(count_data) == 4:
                item_count = struct.unpack('!I', count_data)[0]
                print(f"[DEBUG] 条目数量: {item_count}")

                files = []
                for i in range(item_count):
                    print(f"[DEBUG] 处理第 {i+1} 个条目")

                    # 接收类型 (1=文件, 2=目录)
                    type_data = sock.recv(1)
                    if len(type_data) == 1:
                        item_type = type_data[0]
                        print(f"[DEBUG] 条目类型: {item_type}")

                        # 接收名称长度
                        name_len_data = sock.recv(4)
                        if len(name_len_data) == 4:
                            name_len = struct.unpack('!I', name_len_data)[0]
                            print(f"[DEBUG] 名称长度: {name_len}")

                            # 接收名称
                            name = sock.recv(name_len).decode('utf-8')
                            print(f"[DEBUG] 名称: {name}")

                            # 接收文件大小 (big endian 64-bit)
                            size_data = sock.recv(8)
                            size = struct.unpack('>Q', size_data)[0] if len(size_data) == 8 else 0
                            print(f"[DEBUG] 大小: {size}")

                            # 接收修改时间 (big endian 64-bit)
                            time_data = sock.recv(8)
                            mtime = struct.unpack('>Q', time_data)[0] if len(time_data) == 8 else 0
                            print(f"[DEBUG] 修改时间: {mtime}")

                            files.append({
                                'name': name,
                                'type': 'directory' if item_type == 2 else 'file',
                                'size': size,
                                'mtime': mtime
                            })
                        else:
                            print(f"[ERROR] 名称长度数据不完整: {len(name_len_data)} 字节")
                            break
                    else:
                        print(f"[ERROR] 类型数据不完整: {len(type_data)} 字节")
                        break

                print(f"[DEBUG] 成功解析 {len(files)} 个文件")
                return jsonify({'success': True, 'files': files})
            else:
                print(f"[ERROR] 条目数量数据不完整: {len(count_data)} 字节")
                return jsonify({'success': False, 'message': '接收文件列表失败'})
        else:
            print(f"[ERROR] 服务器返回失败响应: {result}")
            return jsonify({'success': False, 'message': '获取文件列表失败'})

    except Exception as e:
        print(f"[ERROR] 异常: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'message': f'获取文件列表失败: {str(e)}'})
    finally:
        sock.close()

@app.route('/api/mkdir', methods=['POST'])
def create_directory():
    """创建目录API"""
    data = request.json
    username = data.get('username', '')
    path = data.get('path', '')

    if not username or not path:
        return jsonify({'success': False, 'message': '用户名和路径不能为空'})

    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})

    try:
        # 发送创建目录命令
        sock.send(b'M')

        # 发送用户名
        send_string(sock, username)

        # 发送目录路径
        send_string(sock, path)

        # 接收响应
        result = recv_response(sock)

        if result == 1:
            return jsonify({'success': True, 'message': '目录创建成功'})
        else:
            return jsonify({'success': False, 'message': '目录创建失败'})

    except Exception as e:
        return jsonify({'success': False, 'message': f'目录创建失败: {str(e)}'})
    finally:
        sock.close()

@app.route('/api/delete', methods=['POST'])
def delete_item():
    """删除文件或目录API"""
    data = request.json
    username = data.get('username', '')
    path = data.get('path', '')

    if not username or not path:
        return jsonify({'success': False, 'message': '用户名和路径不能为空'})

    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})

    try:
        # 发送删除命令
        sock.send(b'X')

        # 发送用户名
        send_string(sock, username)

        # 发送文件路径
        send_string(sock, path)

        # 接收响应
        result = recv_response(sock)

        if result == 1:
            return jsonify({'success': True, 'message': '删除成功'})
        else:
            return jsonify({'success': False, 'message': '删除失败'})

    except Exception as e:
        return jsonify({'success': False, 'message': f'删除失败: {str(e)}'})
    finally:
        sock.close()

@app.route('/api/rename', methods=['POST'])
def rename_item():
    """重命名文件或目录API"""
    data = request.json
    username = data.get('username', '')
    old_path = data.get('oldPath', '')
    new_path = data.get('newPath', '')

    if not username or not old_path or not new_path:
        return jsonify({'success': False, 'message': '参数不完整'})

    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})

    try:
        print(f"[DEBUG] 重命名请求: 用户={username}, 旧路径={old_path}, 新路径={new_path}")

        # 发送重命名命令
        sock.send(b'N')

        # 发送用户名
        send_string(sock, username)

        # 发送旧路径
        send_string(sock, old_path)

        # 发送新路径
        send_string(sock, new_path)

        # 接收响应
        result = recv_response(sock)
        print(f"[DEBUG] 重命名响应: {result}")

        if result == 1:
            return jsonify({'success': True, 'message': '重命名成功'})
        else:
            return jsonify({'success': False, 'message': '重命名失败'})

    except Exception as e:
        return jsonify({'success': False, 'message': f'重命名失败: {str(e)}'})
    finally:
        sock.close()

@app.route('/api/download', methods=['POST'])
def download_file():
    """文件下载API"""
    data = request.json
    username = data.get('username', '')
    file_path = data.get('filePath', '')

    if not username or not file_path:
        return jsonify({'success': False, 'message': '参数不完整'})

    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})

    try:
        # 发送下载命令
        sock.send(b'D')

        # 发送用户名
        send_string(sock, username)

        # 发送文件名（从路径中提取文件名）
        filename = file_path.split('/')[-1]
        send_string(sock, filename)

        # 接收文件存在标志
        flag_data = sock.recv(1)
        if len(flag_data) != 1 or flag_data[0] == 0:
            return jsonify({'success': False, 'message': '文件不存在'})

        # 接收文件大小
        size_high_data = sock.recv(4)
        size_low_data = sock.recv(4)
        size_high = struct.unpack('!I', size_high_data)[0]
        size_low = struct.unpack('!I', size_low_data)[0]
        file_size = (size_high << 32) | size_low

        # 接收文件内容
        file_content = b''
        bytes_received = 0
        while bytes_received < file_size:
            chunk = sock.recv(min(4096, file_size - bytes_received))
            if not chunk:
                break
            file_content += chunk
            bytes_received += len(chunk)

        # 返回文件内容
        return Response(
            file_content,
            mimetype='application/octet-stream',
            headers={
                'Content-Disposition': f'attachment; filename="{filename}"',
                'Content-Length': str(file_size)
            }
        )

    except Exception as e:
        return jsonify({'success': False, 'message': f'下载失败: {str(e)}'})
    finally:
        sock.close()

@app.route('/api/batch-download', methods=['POST'])
def batch_download():
    """批量下载文件API"""
    data = request.json
    username = data.get('username', '')
    file_paths = data.get('filePaths', [])
    zip_name = data.get('zipName', 'files.zip')

    if not username or not file_paths:
        return jsonify({'success': False, 'message': '参数不完整'})

    print(f"[DEBUG] 批量下载请求: 用户={username}, 文件数量={len(file_paths)}")

    try:
        # 创建内存中的ZIP文件
        zip_buffer = io.BytesIO()

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for file_path in file_paths:
                try:
                    # 连接C服务器下载单个文件
                    sock = connect_to_c_server()
                    if not sock:
                        continue

                    # 发送下载命令
                    sock.send(b'D')

                    # 发送用户名
                    send_string(sock, username)

                    # 发送文件名（从路径中提取文件名）
                    filename = file_path.split('/')[-1]
                    send_string(sock, filename)

                    # 接收文件存在标志
                    flag_data = sock.recv(1)
                    if len(flag_data) != 1 or flag_data[0] == 0:
                        print(f"[DEBUG] 文件不存在: {filename}")
                        sock.close()
                        continue

                    # 接收文件大小
                    size_high_data = sock.recv(4)
                    size_low_data = sock.recv(4)
                    size_high = struct.unpack('!I', size_high_data)[0]
                    size_low = struct.unpack('!I', size_low_data)[0]
                    file_size = (size_high << 32) | size_low

                    # 接收文件内容
                    file_content = b''
                    bytes_received = 0
                    while bytes_received < file_size:
                        chunk = sock.recv(min(4096, file_size - bytes_received))
                        if not chunk:
                            break
                        file_content += chunk
                        bytes_received += len(chunk)

                    # 添加到ZIP文件
                    zip_file.writestr(filename, file_content)
                    print(f"[DEBUG] 已添加到ZIP: {filename} ({file_size} 字节)")

                    sock.close()

                except Exception as e:
                    print(f"[DEBUG] 下载文件失败 {file_path}: {str(e)}")
                    continue

        # 获取ZIP文件内容
        zip_buffer.seek(0)
        zip_content = zip_buffer.getvalue()
        zip_buffer.close()

        if len(zip_content) == 0:
            return jsonify({'success': False, 'message': '没有成功下载任何文件'})

        print(f"[DEBUG] ZIP文件创建完成，大小: {len(zip_content)} 字节")

        # 返回ZIP文件
        return Response(
            zip_content,
            mimetype='application/zip',
            headers={
                'Content-Disposition': f'attachment; filename="{zip_name}"',
                'Content-Length': str(len(zip_content))
            }
        )

    except Exception as e:
        print(f"[DEBUG] 批量下载失败: {str(e)}")
        return jsonify({'success': False, 'message': f'批量下载失败: {str(e)}'})

@app.route('/api/upload', methods=['POST'])
def upload_file():
    """文件上传API"""
    username = request.form.get('username', '')
    target_path = request.form.get('targetPath', '/')

    if not username:
        return jsonify({'success': False, 'message': '用户名不能为空'})
    
    if 'file' not in request.files:
        return jsonify({'success': False, 'message': '没有选择文件'})
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'success': False, 'message': '没有选择文件'})
    
    # 连接C服务器
    sock = connect_to_c_server()
    if not sock:
        return jsonify({'success': False, 'message': '无法连接到服务器'})
    
    try:
        # 发送上传命令
        sock.send(b'U')

        # 发送用户名
        send_string(sock, username)

        # 发送目标目录
        send_string(sock, target_path if target_path != '/' else "")

        # 发送文件名
        send_string(sock, file.filename)

        # 发送文件内容
        file.seek(0)  # 确保从文件开头读取
        while True:
            chunk = file.read(4096)
            if not chunk:
                break
            sock.send(chunk)

        return jsonify({'success': True, 'message': '文件上传成功'})
        
    except Exception as e:
        return jsonify({'success': False, 'message': f'文件上传失败: {str(e)}'})
    finally:
        sock.close()

if __name__ == '__main__':
    print("🌐 Web桥接服务器启动中...")
    print("📡 连接到C服务器:", f"{C_SERVER_HOST}:{C_SERVER_PORT}")
    print("🌍 Web界面地址: http://localhost:5000")
    print("=" * 50)
    
    app.run(host='0.0.0.0', port=5000, debug=True)
